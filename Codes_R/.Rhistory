rename(cl_Variabilité_sms_woe = Variabilité_sms.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_age) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_age_woe = age.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_duree_offre) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_duree_offre_woe = duree_offre.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Reengament_type) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Reengament_type_woe = Reengament_type.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Dead_line_engagement) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Dead_line_engagement_woe = Dead_line_engagement.binned)
base_telecom_2022 <- read_excel("C:/Users/Daniel/Desktop/Mastère ENSAI/Scoring/base_telecom_2023.xlsx") %>%
as.data.frame()
# Supposons que 'df' est votre dataframe
variables_a_transformer <- c("sexe", "flag_migration_hausse","csp",
"flag_migration_baisse", "flag_personnalisation_repondeur", "flag_telechargement_sonnerie",
"Upgrade_tel","Downgrade_tel","Identif_tel","Personnalisation","Internationnal","situation_impayes",
"flag_appels_vers_international","flag_appels_depuis_international","flag_appels_numeros_speciaux")
base_telecom_2022 <- transformer_en_factor(base_telecom_2022, variables_a_transformer)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variation_offre_ini) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variation_offre_ini_woe = Variation_offre_ini.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_anciennete) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_anciennete_woe = anciennete.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_vol) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_vol_woe = Variabilité_vol.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_sms) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_sms_woe = Variabilité_sms.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_age) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_age_woe = age.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_duree_offre) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_duree_offre_woe = duree_offre.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Reengament_type) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Reengament_type_woe = Reengament_type.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Dead_line_engagement) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Dead_line_engagement_woe = Dead_line_engagement.binned)
# 2. Appliquez le modèle et prédisez la probabilité pour chaque client
proba_predictions <- predict(rl, newdata = base_telecom_2022, type = "response")
# Affichez les prédictions de probabilité
print(proba_predictions)
# 1. Créez une nouvelle dataframe contenant les identifiants des clients et leurs prédictions de probabilité
predictions_df <- data.frame(id_client = id_clients, proba_prediction = predict(rl, newdata = base_telecom_2022, type = "response"))
# 1. Créez une nouvelle dataframe contenant les identifiants des clients et leurs prédictions de probabilité
predictions_df <- data.frame(id_client = id_client, proba_prediction = predict(rl, newdata = base_telecom_2022, type = "response"))
# 1. Créez une nouvelle dataframe contenant les identifiants des clients et leurs prédictions de probabilité
predictions_df <- data.frame(id_client = id_client, proba_prediction = predict(rl, newdata = base_telecom_2022, type = "response"))
base_telecom_2022 <- read_excel("C:/Users/Daniel/Desktop/Mastère ENSAI/Scoring/base_telecom_2023.xlsx") %>%
as.data.frame()
# Supposons que 'df' est votre dataframe
variables_a_transformer <- c("sexe", "flag_migration_hausse","csp",
"flag_migration_baisse", "flag_personnalisation_repondeur", "flag_telechargement_sonnerie",
"Upgrade_tel","Downgrade_tel","Identif_tel","Personnalisation","Internationnal","situation_impayes",
"flag_appels_vers_international","flag_appels_depuis_international","flag_appels_numeros_speciaux")
base_telecom_2022 <- transformer_en_factor(base_telecom_2022, variables_a_transformer)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variation_offre_ini) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variation_offre_ini_woe = Variation_offre_ini.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_anciennete) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_anciennete_woe = anciennete.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_vol) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_vol_woe = Variabilité_vol.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_sms) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_sms_woe = Variabilité_sms.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_age) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_age_woe = age.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_duree_offre) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_duree_offre_woe = duree_offre.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Reengament_type) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Reengament_type_woe = Reengament_type.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Dead_line_engagement) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Dead_line_engagement_woe = Dead_line_engagement.binned)
# 1. Créez une nouvelle dataframe contenant les identifiants des clients et leurs prédictions de probabilité
predictions_df <- data.frame(id_client = id_client, proba_prediction = predict(rl, newdata = base_telecom_2022, type = "response"))
# 2. Appliquez le modèle et prédisez la probabilité pour chaque client
proba_predictions <- predict(rl, newdata = base_telecom_2022, type = "response")
predictions_df <- data.frame(id_client = base_telecom_2022$id_client, proba_prediction = proba_predictions)
predictions_df
# Trier la dataframe par ordre décroissant par rapport à la colonne proba_prediction
predictions_df <- predictions_df %>%
arrange(desc(proba_prediction))
# Afficher la dataframe triée
print(predictions_df)
# Sélectionner les 2000 premiers identifiants de clients
top_2000_ids <- head(predictions_df$id_client, 2000)
# Créer un dataframe avec ces identifiants de clients
top_2000_df <- data.frame(id_client = top_2000_ids)
# Écrire les identifiants de clients dans un fichier texte
write.table(top_2000_df, file = "C5_Daniel.txt", row.names = FALSE, col.names = FALSE)
# Sélectionner les 2000 premiers identifiants de clients
top_2000_ids <- head(predictions_df$id_client, 2000)
# Créer un dataframe avec ces identifiants de clients
top_2000_df <- data.frame(id_client = top_2000_ids)
# Écrire les identifiants de clients dans un fichier texte sans les guillemets
write.table(top_2000_df, file = "C3_Daniel.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
base_telecom_2022 <- read_excel("C:/Users/Daniel/Desktop/Mastère ENSAI/Scoring/base_telecom_2023.xlsx") %>%
as.data.frame()
# Supposons que 'df' est votre dataframe
variables_a_transformer <- c("sexe", "flag_migration_hausse","csp",
"flag_migration_baisse", "flag_personnalisation_repondeur", "flag_telechargement_sonnerie",
"Upgrade_tel","Downgrade_tel","Identif_tel","Personnalisation","Internationnal","situation_impayes",
"flag_appels_vers_international","flag_appels_depuis_international","flag_appels_numeros_speciaux")
base_telecom_2022 <- transformer_en_factor(base_telecom_2022, variables_a_transformer)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variation_offre_ini) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variation_offre_ini_woe = Variation_offre_ini.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_anciennete) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_anciennete_woe = anciennete.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_vol) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_vol_woe = Variabilité_vol.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Variabilité_sms) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Variabilité_sms_woe = Variabilité_sms.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_age) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_age_woe = age.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_duree_offre) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_duree_offre_woe = duree_offre.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Reengament_type) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Reengament_type_woe = Reengament_type.binned)
base_telecom_2022 <- woe.binning.deploy(df = base_telecom_2022,
binning = woe_Dead_line_engagement) %>%
mutate(across(ends_with(".binned"), fct_drop)) %>%
rename(cl_Dead_line_engagement_woe = Dead_line_engagement.binned)
# 2. Appliquez le modèle et prédisez la probabilité pour chaque client
proba_predictions <- predict(rl, newdata = base_telecom_2022, type = "response")
predictions_df <- data.frame(id_client = base_telecom_2022$id_client, proba_prediction = proba_predictions)
# Trier la dataframe par ordre décroissant par rapport à la colonne proba_prediction
predictions_df <- predictions_df %>%
arrange(desc(proba_prediction))
# Afficher la dataframe triée
print(predictions_df)
# Sélectionner les 2000 premiers identifiants de clients
top_2000_ids <- head(predictions_df$id_client, 2000)
# Créer un dataframe avec ces identifiants de clients
top_2000_df <- data.frame(id_client = top_2000_ids)
# Écrire les identifiants de clients dans un fichier texte sans les guillemets
write.table(top_2000_df, file = "C4_Daniel.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
simuvarexpl <- matrix(rep(0,300*200),ncol=300,nrow=200)
for (i in 1 :300) simuvarexpl[,i] <- runif(200,-5,5)
# on les normalise
simuvarexpl=scale(simuvarexpl)
simuvarexpl = as.data.frame(simuvarexpl)
View(simuvarexpl)
# TP1
# ENSAI
library(mvtnorm)
library(mnormt)
"
On peut centrer et réduire nos données au tout début, mais cela n'est pas indispensable
Le fait d'être centré on sait comment les Bêta agissent effectivement sur la variable Y
Ici par construction elles sont en moyennes centrée
"
simuvarexpl <- matrix(rep(0,300*200),ncol=300,nrow=200)
for (i in 1 :300) simuvarexpl[,i] <- runif(200,-5,5)
# on les normalise
simuvarexpl=scale(simuvarexpl)
simuvarexpl = as.data.frame(simuvarexpl)
View(simuvarexpl)
# vrais indices de la r?gression
trueind <- c(10,20,30,40,50)
# les valeurs non nulles des beta sont
beta <- c(1,-1,2,-2,3)
# simulation des Y
ysimu <- as.matrix(simuvarexpl)[,trueind]%*% beta + rnorm(200,0,2)
###############################################################
# Fonction de pr?diction
# Elle servra ? pr?dire des valeurs de Y
# ? partir des beta estim?s et des x du jeu de donn?es test
predictions <- function(matableTest,muchap,betachap)
{
ychap <- muchap * rep(1,dim(matableTest)[1])+ as.matrix(matableTest[,]) %*% betachap
return(ychap)
}
############################
# Programme pour sélectionner les coefficients
# les plus significatifs, c?d ceux qui sortent d'un intervalle (mini, maxi)
# et ce programme renvoie les noms des variables associ?es
subsetSelected <- function(resAlgo, varexpl, mini, maxi)
{
numselected <- c(which(resAlgo < mini), which(resAlgo > maxi))
selected <- character()
valeurs <- numeric()
for (i in 1 :length(numselected))
{
selected[i] <- names(varexpl)[numselected[i]]
valeurs[i] <- resAlgo[numselected[i]]
}
subset <- cbind(selected, valeurs)
subset <- as.data.frame(subset)
subset$valeurs <- as.numeric(as.vector(subset$valeurs))
return(subset)
}
#####################Mod?le RR
# Y = 1*mu + X beta + eps # notation du cours
# avec les notations du package mu = beta
# beta = u
# X = Z
# le 1 = X
# Y = X*beta + Z u + e
library(rrBLUP)
install.packages("rrBLUP")
#####################Mod?le RR
# Y = 1*mu + X beta + eps # notation du cours
# avec les notations du package mu = beta
# beta = u
# X = Z
# le 1 = X
# Y = X*beta + Z u + e
library(rrBLUP)
######## le mod?le sur le training (les 100 premi?res observations)
resBLUP <- mixed.solve(ysimu[1 :100], Z = as.matrix(simuvarexpl[1 :100, ]), X = as.matrix(rep(1,
100)), method = "REML")
# les notations de mixed.solve sont :
# notre mu = beta
# notre beta = u
# notre epsilon = e
######## les estimations
muchap <- resBLUP$beta  # moyenne  mu
muchap
betachap <- resBLUP$u   # les coefficients beta
# c'est un vecteur de longueur p=300
par(mfrow=c(1,1))
plot(sort(abs(betachap)))   # on voit un fort shrinkage
betachap[50]
resBLUP$Ve  # variance des epsilon
resBLUP$Vu # variance des betas
betachap[50]
resBLUP$Ve  # variance des epsilon
resBLUP$Vu # variance des betas
################### Les pr?dictions sur les donn?es du jeu test (les 100 derni?res valeurs)
predBLUP <- predictions(simuvarexpl[101 :200, ], muchap, betachap)
################ corr?lation en y pr?dits et y observ?s (sur jeu test)
cor(ysimu[101 :200], predBLUP)
# 0.5032711
plot(predBLUP ~ ysimu[101 :200])
abline(0,1)
############ Sélection des coefficients
plot(betachap,xlab="Indice variable",ylab="Param?tre de r?gression associ?",main="rrBLUP")
plot(sort(abs(betachap)))
boxplot(betachap)
plot(sort(abs(betachap)))
bb <- boxplot(betachap)
varselectedBLUP <- subsetSelected(betachap,simuvarexpl,bb$stats[1,], bb$stats[5,])
varselectedBLUP
################ Bayes A
library(MCMCpack) ; library(LearnBayes) ; library(invgamma)
################ Bayes A
library(MCMCpack)
library(LearnBayes)
library(invgamma)
install.packages("MCMCpack")
install.packages("LearnBayes")
################ Bayes A
library(MCMCpack)
library(LearnBayes)
library(invgamma)
################## le mod?le
# y|beta, sigmaSeps, mu ~N(mu + X beta , sigma2eps)
# u uniforme
# beta ~N(0, sigma2(1), ..., sigma2(p))
# sigma2(i) ~ InvGamma(a,b) iid
# sigma2eps ~InvGamma(c,d)
BayesA <- function(y,X,a,b,c,d,muinit,nbiter,nburn)
{
p <- dim(X)[2]
n <- dim(X)[1]
# resultats a garder
resbeta <- matrix(rep(0,p*(nbiter-nburn)),nrow=p,ncol=(nbiter-nburn))
ressigma2beta <- matrix(rep(0,p*(nbiter-nburn)),nrow=p,ncol=(nbiter-nburn))
resmu <- rep(0,nbiter-nburn)
ressigma2eps <- rep(0,nbiter-nburn)
# initialisation
beta <- rep(0,p)
mu <- muinit
sigma2beta <- rinvgamma(p,a,b) # initialisation des valeurs
sigma2eps <- rinvgamma(1,c,d)
#iterations
for (iter in 1 :nbiter)
{
print(iter)
Sigmabeta <- solve(t(X)%*%X/sigma2eps + diag(1/sigma2beta))
beta <- as.numeric(rmnorm(1,Sigmabeta%*%t(X)%*%(y-mu*rep(1,n))/sigma2eps, Sigmabeta))
mu <- rnorm(1,t(rep(1,n))%*%(y-X%*%beta)/n,sqrt(sigma2eps/n))
for (j in 1 :p)
{
sigma2beta[j] <- rinvgamma(1,a+1/2,b+1/2*beta[j]^2)
}
sigma2eps <- rinvgamma(1,c+n/2,d+1/2*t(y-mu*rep(1,n)-X%*%beta)%*%(y-mu*rep(1,n)-X%*%beta))
if (iter > nburn)
{
resbeta[,iter-nburn] <- beta
ressigma2beta[,iter-nburn] <- sigma2beta
resmu[iter-nburn] <- mu
ressigma2eps[iter-nburn] <- sigma2eps
}
}
return(list(resbeta,ressigma2beta,resmu,ressigma2eps))
}
####################### Application sur nos donn?es
# les a priori sont des inverses gamma
# de param?tres (a,b) et (c,d)
# leurs moyennes et variances sont
a=c=1 ; b=d=1
b/(a-1) ; d/(c-1)   # esp?rance d'une inv gamma
b^2/((a-1)^2*(a-2)) ; d^2/((c-1)^2*(c-2)) # variance inv gamma
# avec ces valeurs ont met des a priori tr?s vague, de variance infinie
priora <- 2
priorb <- 1
priorc <- 2
priord <- 1
resBAYESA <- BayesA(ysimu[1 :100], as.matrix(simuvarexpl[1 :100, ]), priora, priorb, priorc,
priord, mean(ysimu[1 :100]), 2000, 1500)
moybeta <- apply(resBAYESA[[1]], 1, mean) # estimateurs des beta
moysigma2beta <- apply(resBAYESA[[2]], 1, mean)
moymu <- mean(resBAYESA[[3]])
moysigma2eps <- mean(resBAYESA[[4]])
moybeta[50]
plot(moybeta)
plot(sort(abs(moybeta)))
moymu
plot(moysigma2beta)
moysigma2eps
# regardons les trajectoires :
par(mfrow=c(2,1))
plot(resBAYESA[[1]][50, ])  # pour beta50
plot(resBAYESA[[2]][1, ])   # pour s2beta1
plot(resBAYESA[[3]])        # pour mu
plot(resBAYESA[[4]])        # pour s2eps
# on peut relancer avec des a priori moins vagues
# par exemple en prenant
priora <- 1
priorb <- 10
priorc <- 1
priord <- 10
resBAYESA <- BayesA(ysimu[1 :100], as.matrix(simuvarexpl[1 :100, ]), priora, priorb, priorc,
priord, mean(ysimu[1 :100]), 2000, 1500)
moybeta <- apply(resBAYESA[[1]], 1, mean) # estimateurs des beta
moysigma2beta <- apply(resBAYESA[[2]], 1, mean)
moymu <- mean(resBAYESA[[3]])
moysigma2eps <- mean(resBAYESA[[4]])
moybeta[50]
plot(moybeta)
plot(sort(abs(moybeta)))
moymu
plot(moysigma2beta)
moysigma2eps
# regardons les trajectoires :
par(mfrow=c(2,1))
plot(resBAYESA[[1]][50, ])  # pour beta50
plot(resBAYESA[[2]][1, ])   # pour s2beta1
plot(resBAYESA[[3]])        # pour mu
plot(resBAYESA[[4]])        # pour s2eps
# on peut relancer avec des a priori moins vagues
# par exemple en prenant
priora <- 1
priorb <- 10
priorc <- 1
priord <- 10
################# SSVS
####### Mod?lisation
selection_SSVS <- function (vardep, varexpl, nbiter, nburn, lec, nbSelecInit,nbToChange,Pi)
{
X <- as.matrix(varexpl)
y <- as.numeric(as.vector(vardep))
y <- y - mean(y)
nind <- dim(X)[1]
nvar <- dim(X)[2]
sumgamma <- rep(0, nvar)
nbactu <- 0
nbselecactu <- numeric()
indgamma10 <- sample(c(1:nvar), nbSelecInit, replace = FALSE)
gamma0 <- rep(0, nvar)
for (i in 1:nbSelecInit) {
gamma0[indgamma10[i]] <- 1
}
indgamma1 <- indgamma10
gamma <- gamma0
nbSelec <- nbSelecInit
for (iter in 1:nbiter) {
print(iter)
gammaprop <- gamma
indgamma1prop <- indgamma1
indToChange <- sample(c(1:nvar), nbToChange, replace = FALSE)
for (i in 1:nbToChange){
if (gamma[indToChange[i]]==0){
gammaprop[indToChange[i]] <- 1
indgamma1prop <- c(indgamma1prop,indToChange[i])
}
else {
gammaprop[indToChange[i]] <- 0
indremove <- which(indgamma1prop==indToChange[i])
indgamma1prop <- indgamma1prop[-indremove]
}
}
nbSelecprop <- length(indgamma1prop)
if (nbSelecprop==0){ # condition pour empecher gamma avec que des 0
cond <- 0
while(cond==0){
gammaprop <- gamma
indgamma1prop <- indgamma1
indToChange <- sample(c(1:nvar), nbToChange, replace = FALSE)
for (i in 1:nbToChange){
if (gamma[indToChange[i]]==0){
gammaprop[indToChange[i]] <- 1
indgamma1prop <- c(indgamma1prop,indToChange[i])
}
else {
gammaprop[indToChange[i]] <- 0
indremove <- which(indgamma1prop==indToChange[i])
indgamma1prop <- indgamma1prop[-indremove]
}
}
nbSelecprop <- length(indgamma1prop)
if (nbSelecprop>0){cond <- 1}
}
}
indgamma1 <- which(gamma == 1)
nbSelec <- length(indgamma1)
Xgamma <- X[, indgamma1]
Xgammaprop <- X[, indgamma1prop]
temp <- (t(y)%*%(diag(rep(1,nind))-lec/(1+lec)*Xgammaprop%*%solve(t(Xgammaprop)%*%Xgammaprop)%*%t(Xgammaprop))%*%y)/(t(y)%*%(diag(rep(1,nind))-lec/(1+lec)*Xgamma%*%solve(t(Xgamma)%*%Xgamma)%*%t(Xgamma))%*%y)
A <- (1+lec)^((nbSelec-nbSelecprop)/2)*(Pi/(1-Pi))^(nbSelecprop-nbSelec)*temp^(-(nind-1)/2)
probaccept1 <- min(1,A)
seuil <- runif(1)
if (seuil < probaccept1){
gamma <- gammaprop
indgamma1 <- indgamma1prop
nbSelec <- nbSelecprop
nbactu <- nbactu+1
nbselecactu <- c(nbselecactu,nbSelec)
}
if (iter > nburn) {
sumgamma <- sumgamma + gamma
}
}
return(list(sumgamma,nbactu,nbselecactu))
}
#### Initialisation
nbinit <- 10 # nombre de beta non nuls au d?part
nbToChange <- 2 # nombre de beta que l'on propose de changer ? chaque fois
Pi <- 10/300   # la probabilit? de choisir un beta (en moyenne 10 car il y en a 300)
lec <- 50  # pr?conisation : entre 10 et 100
resSSVS <- selection_SSVS(ysimu[1 :100], as.matrix(simuvarexpl[1 :100, ]), 4000, 3000, lec,
nbinit, nbToChange, Pi)
resSSVS[[2]]  # on voit combien il y a eu d'?changes dans les 1000 derniers run
resSSVS[[3]]  # on voit le nbre de variables s?lectionn?es lors de ces ?changes
resSSVS[[1]]
####### S?lection
plot(sort(abs(resSSVS[[1]])))
boxplot(resSSVS[[1]])
plot(resSSVS[[1]],xlab="Indice variable",ylab= "Nombre de s?lections post-burn-in", main="SSVS")
varselectedSSVS <- subsetSelected(resSSVS[[1]],simuvarexpl,0,999)
varselectedSSVS
which(resSSVS[[1]]>900)
resSSVS <- selection_SSVS(ysimu[1 :100], as.matrix(simuvarexpl[1 :100, ]), 8000, 7000, lec,
nbinit, nbToChange, Pi)
resSSVS[[2]]  # on voit combien il y a eu d'?changes dans les 1000 derniers run
resSSVS[[3]]  # on voit le nbre de variables s?lectionn?es lors de ces ?changes
resSSVS[[1]]
####### S?lection
plot(sort(abs(resSSVS[[1]])))
boxplot(resSSVS[[1]])
plot(resSSVS[[1]],xlab="Indice variable",ylab= "Nombre de s?lections post-burn-in", main="SSVS")
varselectedSSVS <- subsetSelected(resSSVS[[1]],simuvarexpl,0,999)
varselectedSSVS
